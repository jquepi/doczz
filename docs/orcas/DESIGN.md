## 存储层设计

### 存储层的设计原则

1. 元数据和数据分开存储
- 提供存储适配器，这样你可以随意修改成你想要的实现

2. 按对象大小分类存储（better to have）
- 小对象支持打包存储
- 大对象存储分块存储

3. 只追加（WORM）模式

4. 秒传（对象级重复数据删除）

5. 支持常见压缩方法

6. 支持加密方法（数据私有安全，常见的国密SM4、国际AES-256）
- 拥有正确密钥的设备才能在设备端访问数据（全链路）

### 元数据设计

- 一般元数据存储会设计成全路径或者父子对象id的方式

<table style="text-align: center">
   <tr>
      <td>方案</td>
      <td>优点</td>
      <td>缺点</td>
   </tr>
   <tr>
      <td>全路径</td>
      <td>前缀查询，定位较快<br/></td>
      <td>移动/重命名需要批量修改前缀</td>
   </tr>
   <tr>
      <td>父子id</td>
      <td>移动可以配合引用功能</td>
      <td>需要每一级查询（可以通过给父id解决）
      ；客户端需要维护id和名称的关系</td>
   </tr>
</table>

这里我们选择父子id

### 接口设计

- 批量写入对象信息，同时可以带部分对象的秒传/秒传预筛选
- 读取对象信息
- 列举对象信息：无限加载模式，支持按对象名、对象类型过滤，支持对象名称、大小、时间排序
- 随机读取数据的一部分（在线播放和在线预览等）
- id生成器，默认单机的，如果是分布式的，可能需要通过配置支持

#### 【对象的属性】

- 父级的id
- 对象名称
- 对象大小
- 创建时间
- 修改时间（如果没有，那就是创建时间）
- 访问时间（如果没有，那就是修改时间>创建时间）
- 对象的类型
- 数据id
- 幂等操作id
- 快照版本

#### 【数据的属性】

- 是否压缩
- 是否加密
- 原始MD5值
- 原始CRC32值
- 前32KB头部CRC32值
- 8KB对齐，最大尽量在4MB以内
- 打包块的ID和偏移位置

### 端到端的实现：

- 在客户端做加解密和解压缩
- 本地的实现，数据直接写入存储；远端的实现，数据通过rpc传输，调用方无法感觉到差别

### 上传对象的过程：

1. hdrCRC32和长度来预检查是否可能秒传（可以用阈值来优化小对象直接跳过预检查）
2. 没有可能的直接上传
3. 有可能的，计算整个对象的MD5和CRC32后尝试秒传
4. 秒传失败，转普通上传