# 从0开始设计对象存储

## 背景介绍

作者Orca，11年从毕业开始接触存储，从最早的单机对象存储（基于对象系统分chunk，随机写转顺序写）到分布式对象存储（基于MySQL+LevelDB+OpenStack Swift、 MongoDB + 类Swift/ceph存储、Paxos+LevelDB），有的是基于存储的应用（备份一体机、企业云盘、IM、feed收发件箱），也有单纯的公有、私有云存储服务。

## 需求

我目前期望实现一个低成本的单机存储用于存储私有数据，能够提供一定的扩展性，在此基础上扩展成分布式版本，它应该能够运行在配置较低（CPU、内存、磁盘、网络）的设备上，比如树莓派或者ARM上，存储可能也是廉价的低擦写次数的，比如TLC的sd卡。

## 现状

近10多年来，开源基础设施大量涌现，动手实现一个简单的单机存储越来越容易。比如：LevelDB/RocksDB、etcd/consul、各种Paxos/Raft的实现。这里我们先从单机对象存储开始说起，通过提供相同的适配器，让实现单节点单副本、单节点多副本、单机纠删码、多节点多副本、多集群版变成简单的事情。通过系列文章，我希望能够手把手带你实现一个对象存储，借鉴同类设计的好的经验，一起交付一个好(si)东(bu)西(xiang)，并且这应该是不限制语言的，文中使用Go语言作为示例。

### 我希望它该有的样子

- 尽可能快
- 支持加密和压缩（按需）
- 支持扩容
- **传输层透明（端到端）**
- 能够保障数据可用性
- 支持Range:bytes随机读部分数据

如果有这些功能，那就更好了：

- 秒传
- 权限控制（桶/对象），可以扩展外链分享功能
- 多版本：支持存储对象的多个版本，包括快照和闪回（flashback）
- 差分同步：多版本之间能减少传输和存储量
- 纠删码或者变长重删：节省归档类存储的占用空间
- 能够识别对象类型：支持自定义插件
- 在线预览：图片、视频、office文档、pdf、cad等
- ...

### 反思过度设计

- 这么多年工作，收获了不少经验，也过不少过度设计、走弯路的经历，归根到底，基于场景去设计和实现才更有意义。
- 断电一致性中关于一定保障数据完整的部分，也就是数据一旦写入，就需要保证数据可用性，以前的方案是实时刷盘，改进方案是几秒刷一次盘，客户端连接后，检查是否有需要重传的损坏的对象（服务启动时检查上次是否异常退出）即可。
- 在数据部分还保留了上下级关系，冗余的同时，增加了很多维护成本。
- 秒传在后续版本才引入，以前数据默认挂在元数据下的，导致了实现上的困难和数据的重复。

#### 领域模型

- 主要分为用户、内容两部分

  - 它们之间的关联是访问和权限控制

  - 用户分为管理员和普通用户

  - 内容按类别分为元数据和数据
  
    - 元数据又有桶信息、对象信息、数据信息，桶里面用来存储对象，每个对象信息可以关联数据信息，比如版本和预览的数据等，也可以不关联数据，比如目录和文件对象

![architecture](https://orcastor.github.io/doc//assets/img/arch.png)

